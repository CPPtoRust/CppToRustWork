 /*************************************************************************
 * This file was generated by CRUST by an automated semantics preserving
 * translation from C/C++ to Rust
 * CRUST isn't perfect and may require manual editing
 * Check warnings and errors and refer to the official Rust Documentation
 ************************************************************************/
 /* Inline Functions for positions.{h,cc}.

   Copyright (C) 1989-1998, 2000, 2002 Free Software Foundation, Inc.
   Written by Douglas C. Schmidt <schmidt@ics.uci.edu>
   and Bruno Haible <bruno@clisp.org>.

   
 
 
 // This needs:
 //#include <string.h>
 
 /* ---------------------------- Class Positions ---------------------------- */
 
 
 /* Constructors.  */
 
 
 INLINE 
 Positions :: Positions ( ) 
 : _useall ( false ) ; 
 _size ( 0 ) 
 { 
 
 
 INLINE 
 Positions :: Positions ( int pos1 ) 
 : _useall ( false ) ; 
 _size ( 1 ) 
 { 
 _positions [ 0 ] = pos1 ; 
 
 
 INLINE 
 Positions :: Positions ( int pos1 , int pos2 ) 
 : _useall ( false ) ; 
 _size ( 2 ) 
 { 
 _positions [ 0 ] = pos1 ; 
 _positions [ 1 ] = pos2 ; 
 
 
 /* Copy constructor.  */
 
 
 INLINE 
 Positions :: Positions ( const Positions & src ) 
 : _useall ( src . _useall ) ; 
 _size ( src . _size ) 
 { 
 memcpy ( _positions , src . _positions , _size * sizeof ( _positions [ 0 ] ) ) ; 
 
 
 /* Assignment operator.  */
 
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let Positions = INLINE { }; 
 _size = src ; 
 memcpy ( _positions , src . _positions , _size * sizeof ( _positions [ 0 ] ) ) ; 
 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 return * this ; 
 
 
 /* Accessors.  */
 
 
 INLINE 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static _useall : bool ; 
 
 
 INLINE 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static index : i32 ; 
 
 
 INLINE unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static _size : i32 ; 
 
 
 /* Write access.  */
 
 
 INLINE 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static _useall : void = useall; ; 
 if ( useall ) == true { 
 { 
 /* The positions are 0, 1, ..., MAX_KEY_POS-1, in descending order.  */
 
 _size = MAX_KEY_POS ; } 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static ptr : & i32 = & ; ; 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static i : i32 = MAX_KEY_POS-1; ; while i >= 0 { 
 * ptr +=1 = i ; i -=1 ; } 
 
 INLINE 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static _size : void = size; ; 
 
 
 /* Sorts the array in reverse order.
   Returns true if there are no duplicates, false otherwise.  */
 
 INLINE 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static _useall : bool ; 
 
 /* Bubble sort.  */
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static duplicate_free : bool = true; ; 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static base : & i32 = & ; ; 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static len : i32 = _size; ; 
 
 i = 1 ; unsigned int i ; while i < len { 
 { 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static j : i32 ; i +=1 ; } 
 
 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 return duplicate_free ; 
 
 
 /* Creates an iterator, returning the positions in descending order.  */
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let PositionIterator = INLINE { }; 
 
 
 /* Creates an iterator, returning the positions in descending order,
   that apply to strings of length <= maxlen.  */
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let PositionIterator = INLINE { }; 
 
 
 /* Creates an iterator, returning the positions in ascending order.  */
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let PositionReverseIterator = INLINE { }; 
 
 
 /* Creates an iterator, returning the positions in ascending order,
   that apply to strings of length <= maxlen.  */
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let PositionReverseIterator = INLINE { }; 
 
 
 /* ------------------------- Class PositionIterator ------------------------ */
 
 
 /* Initializes an iterator through POSITIONS.  */
 
 INLINE 
 PositionIterator :: PositionIterator ( Positions const & positions ) 
 : _set ( positions ) ; 
 _index ( 0 ) 
 { 
 
 
 /* Initializes an iterator through POSITIONS, ignoring positions >= maxlen.  */
 
 INLINE 
 PositionIterator :: PositionIterator ( Positions const & positions , int maxlen ) 
 : _set ( positions ) 
 { 
 if ( positions . _useall ) == true { 
 _index = ( ; } 
 else { 
 { 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static index : i32 ; } 
 index = 0 ; while 
 index < positions . _size && positions . _positions [ index ] >= maxlen { 
 ; 
 index +=1 ; } 
 
 /* Returns the number of remaining positions, i.e. how often next() will
   return a value != EOS.  */
 
 INLINE unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static _index : i32 ; 
 
 
 /* Copy constructor.  */
 
 INLINE 
 PositionIterator :: PositionIterator ( const PositionIterator & src ) 
 : _set ( src . _set ) ; 
 _index ( src . _index ) 
 { 
 
 
 /* --------------------- Class PositionReverseIterator --------------------- */
 
 
 /* Initializes an iterator through POSITIONS.  */
 
 INLINE 
 PositionReverseIterator :: PositionReverseIterator ( Positions const & positions ) 
 : _set ( positions ) ; 
 _index ( _set . _size ) ; 
 _minindex ( 0 ) 
 { 
 
 
 /* Initializes an iterator through POSITIONS, ignoring positions >= maxlen.  */
 
 INLINE 
 PositionReverseIterator :: PositionReverseIterator ( Positions const & positions , int maxlen ) 
 : _set ( positions ) ; 
 _index ( _set . _size ) 
 { 
 if ( positions . _useall ) == true { 
 _minindex = ( ; } 
 else { 
 { 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static index : i32 ; } 
 index = 0 ; while 
 index < positions . _size && positions . _positions [ index ] >= maxlen { 
 ; 
 index +=1 ; } 
 
 /* Returns the number of remaining positions, i.e. how often next() will
   return a value != EOS.  */
 
 INLINE unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static _minindex : i32 ; 
 
 
 /* Copy constructor.  */
 
 INLINE 
 PositionReverseIterator :: PositionReverseIterator ( const PositionReverseIterator & src ) 
 : _set ( src . _set ) ; 
 _index ( src . _index ) ; 
 _minindex ( src . _minindex ) 
 { 
 
