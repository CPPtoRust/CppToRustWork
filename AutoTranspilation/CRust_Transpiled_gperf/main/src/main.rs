 /*************************************************************************
 * This file was generated by CRUST by an automated semantics preserving
 * translation from C/C++ to Rust
 * CRUST isn't perfect and may require manual editing
 * Check warnings and errors and refer to the official Rust Documentation
 ************************************************************************/
 /* Driver program for the hash function generator
   Copyright (C) 1989-1998, 2000, 2002-2003, 2009 Free Software Foundation, Inc.
   Written by Douglas C. Schmidt <schmidt@ics.uci.edu>
   and Bruno Haible <bruno@clisp.org>.

   
 
 
 
/** Crust doesn't resolve C/C++ dependencies or included header.
* You may have to define your own module and implement those functionality in Rust 
* Or you can translate header file with Crust to produce Rust code. * 
* >>>>>>>> # include < stdio . h >
 **/
 * >>>>>>>> # include < stdlib . h >
 **/
 * >>>>>>>> # include < string . h >
 **/
 * >>>>>>>> # include "options.h" 
 # include "input.h" 
 # include "search.h" 
 # include "output.h" 
 
 
 /* ------------------------------------------------------------------------- */ 
 
 /* This Keyword factory produces KeywordExt instances.  */ 
 
 class KeywordExt_Factory : public Keyword_Factory 
 { 
 virtual Keyword * create_keyword ( const char * allchars , int allchars_length , 
 const char * rest ) ; 
 } ; 
 
 Keyword * 
 KeywordExt_Factory :: create_keyword ( const char * allchars , int allchars_length , const char * rest ) 
 { 
 return new KeywordExt ( allchars , allchars_length , rest ) ; 
 } 
 
 /* ------------------------------------------------------------------------- */ 
 
 int 
 main ( int argc , char * argv [ ] ) 
 { 
 int exitcode ; 
 
 /* Set the Options.  Open the input file and assign stdin to it.  */ 
 option . parse_options ( argc , argv ) ; 
 
 /* Open the input file.  */ 
 if ( option . get_input_file_name ( ) ) 
 if ( ! freopen ( option . get_input_file_name ( ) , "r" , stdin ) ) 
 { 
 fprintf ( stderr , "Cannot open input file '%s'\n" , 
 option . get_input_file_name ( ) ) ; 
 exit ( 1 ) ; 
 } 
 
 { 
 /* Initialize the keyword list.  */ 
 KeywordExt_Factory factory ; 
 Input inputter ( stdin , & factory ) ; 
 inputter . read_input ( ) ; 
 /* We can cast the keyword list to KeywordExt_List* because its list
       elements were created by KeywordExt_Factory.  */ 
 KeywordExt_List * list = static_cast < KeywordExt_List * >
 **/
 ( inputter . _head ) ; 
 
 { 
 /* Search for a good hash function.  */
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let searcher = Search { }; 
 searcher . optimize ( ) ; 
 list = searcher ; 
 
 /* Open the output file.  */
 
 if ( option . get_output_file_name ( ) == true { ) 
 if ( strcmp ( option . get_output_file_name ( ) == true { ; "-" ) != 0 ) 
 if ( ! freopen ( option . get_output_file_name ( ) == true { ; "w" ; stdout ) ) 
 { 
 fprintf ( stderr , "Cannot open output file '%s'\n" , 
 option . get_output_file_name ( ) ) ; } } } 
 exit ( 1 ) ; 
 
 
 { 
 /* Output the hash function code.  */
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let outputter = Output { }; 
 outputter . output ( ) ; 
 
 /* Check for write error on stdout.  */
 
 exitcode = 0 ; 
 if ( fflush ( stdout ) == true { || ferror ( stdout ) ) 
 { 
 fprintf ( stderr , "error while writing output file\n" ) ; } 
 exitcode = 1 ; 
 
 
 /* Here we run the Output destructor.  */
 
 
 /* Here we run the Search destructor.  */
 
 
 
 /* Also delete the list that was allocated inside Input and reordered
       inside Search.  */
 
 ptr = list ; KeywordExt_List * ptr ; while ptr { ) 
 { 
 KeywordExt * keyword = ptr -> first ( ) ; ptr = ptr ; } 
 delete_list ( list ) ; 
 
 /* Here we run the Input destructor.  */
 
 
 
 /* Don't use exit() here, it skips the destructors.  */
 
 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 return exitcode ; 
 
