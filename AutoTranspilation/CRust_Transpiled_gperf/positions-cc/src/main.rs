 /*************************************************************************
 * This file was generated by CRUST by an automated semantics preserving
 * translation from C/C++ to Rust
 * CRUST isn't perfect and may require manual editing
 * Check warnings and errors and refer to the official Rust Documentation
 ************************************************************************/
 /* A set of byte positions.
   Copyright (C) 1989-1998, 2000, 2002 Free Software Foundation, Inc.
   Written by Douglas C. Schmidt <schmidt@ics.uci.edu>
   and Bruno Haible <bruno@clisp.org>.

   
 
 
 /* Specification. */
 
 
/** Crust doesn't resolve C/C++ dependencies or included header.
* You may have to define your own module and implement those functionality in Rust 
* Or you can translate header file with Crust to produce Rust code. * 
* >>>>>>>> # include "positions.h" 
 
 # include < stdio . h >
 **/
 * >>>>>>>> # include < stdlib . h >
 **/
 /* declares exit() */
 * >>>>>>>> # include < string . h >
 **/
 
 
 /* ---------------------------- Class Positions ---------------------------- */
 
 
 /* Set operations.  Assumes the array is in reverse order.  */
 
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static count : bool = _size; ; 
 const 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & i32 = & +_size-1; ; 
 
 while count > 0 { 
 { 
 if ( * p == pos ) == true { 
 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 true } p -=1 ; count -=1 ; } 
 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 return false ; 
 
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static set_useall : void ; 
 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static count : i32 = _size; ; 
 
 if ( count == MAX_SIZE ) == true { 
 { 
 fprintf ( stderr , "Positions::add internal error: overflow\n" ) ; } 
 exit ( 1 ) ; 
 
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & i32 = & +_size-1; ; 
 
 while count > 0 { 
 { 
 if ( * p == pos ) == true { 
 { 
 fprintf ( stderr , "Positions::add internal error: duplicate\n" ) ; } p -=1 ; count -=1 ; } 
 p [ 1 ] = pos ; 
 _size +=1 ; 
 
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static set_useall : void ; 
 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static count : i32 = _size; ; 
 if ( count > 0 ) == true { 
 { 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & i32 = & +_size-1; ; } 
 
 if ( * p == pos ) == true { 
 { 
 _size -=1 ; } 
 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 return ; 
 
 if ( * p < pos ) == true { 
 { 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static prev : i32 = *p; ; } 
 
 loop { 
 { 
 p -=1 ; } 
 
 
 fprintf ( stderr , "Positions::remove internal error: not found\n" ) ; 
 exit ( 1 ) ; 
 
 
 /* Output in external syntax.  */
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static printf : void ; 
 else { 
 { 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static first : bool = true; ; } 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static seen_LASTCHAR : bool = false; ; 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static count : i32 = _size; ; 
 const 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & i32 = & +_size-1; ; 
 
 while count > 0 { 
 { 
 count -=1 ; p -=1 ; } 
 if ( seen_LASTCHAR ) == true { 
 { 
 if ( ! first ) == true { 
 printf ( "," ) ; } } 
 printf ( "$" ) ; 
 
 
 
 
 /* ------------------------------------------------------------------------- */
 
 * >>>>>>>> # ifndef __OPTIMIZE__ 
 
 # define INLINE /* not inline */ 
 # include "positions.icc" 
 # undef INLINE 
 
 # endif /* not defined __OPTIMIZE__ */ 
