 /*************************************************************************
 * This file was generated by CRUST by an automated semantics preserving
 * translation from C/C++ to Rust
 * CRUST isn't perfect and may require manual editing
 * Check warnings and errors and refer to the official Rust Documentation
 ************************************************************************/
 /* Input routines.
   Copyright (C) 1989-1998, 2002-2004 Free Software Foundation, Inc.
   Written by Douglas C. Schmidt <schmidt@ics.uci.edu>
   and Bruno Haible <bruno@clisp.org>.

   
 
 
 /* Specification. */
 
 
/** Crust doesn't resolve C/C++ dependencies or included header.
* You may have to define your own module and implement those functionality in Rust 
* Or you can translate header file with Crust to produce Rust code. * 
* >>>>>>>> # include "input.h" 
 
 # include < stdio . h >
 **/
 * >>>>>>>> # include < stdlib . h >
 **/
 /* declares exit() */
 * >>>>>>>> # include < string . h >
 **/
 /* declares strncpy(), strchr() */
 * >>>>>>>> # include < limits . h >
 **/
 /* defines UCHAR_MAX etc. */
 * >>>>>>>> # include "options.h" 
 # include "getline.h" 
 
 Input :: Input ( FILE * stream , Keyword_Factory * keyword_factory ) 
 : _stream ( stream ) , _factory ( keyword_factory ) 
 { 
 } 
 
 /* Returns a pretty representation of the input file name, for error and
   warning messages.  */ 
 static const char * 
 pretty_input_file_name ( ) 
 { 
 if ( option . get_input_file_name ( ) ) 
 return option . get_input_file_name ( ) ; 
 else 
 return "(standard input)" ; 
 } 
 
 /* Returns true if the given line contains a "%DECL" declaration.  */ 
 static bool 
 is_declaration ( const char * line , const char * line_end , unsigned int lineno , 
 const char * decl ) 
 { 
 /* Skip '%'.  */ 
 line ++ ; 
 
 /* Skip DECL.  */ 
 for ( const char * d = decl ; * d ; d ++ ) 
 { 
 if ( ! ( line < line_end ) ) 
 return false ; 
 if ( ! ( * line == * d || ( * d == '-' && * line == '_' ) ) ) 
 return false ; 
 line ++ ; 
 } 
 if ( line < line_end 
 && ( ( * line >= 'A' && * line <= 'Z' ) 
 || ( * line >= 'a' && * line <= 'z' ) 
 || * line == '-' || * line == '_' ) ) 
 return false ; 
 
 /* OK, found DECL.  */ 
 
 /* Skip whitespace.  */ 
 while ( line < line_end && ( * line == ' ' || * line == '\t' ) ) 
 line ++ ; 
 
 /* Expect end of line.  */ 
 if ( line < line_end && * line != '\n' ) 
 { 
 fprintf ( stderr , "%s:%u: junk after declaration\n" , 
 pretty_input_file_name ( ) , lineno ) ; 
 exit ( 1 ) ; 
 } 
 
 return true ; 
 } 
 
 /* Tests if the given line contains a "%DECL=ARG" declaration.
   If yes, it sets *ARGP to the argument, and returns true.
   Otherwise, it returns false.  */ 
 static bool 
 is_declaration_with_arg ( const char * line , const char * line_end , 
 unsigned int lineno , 
 const char * decl , char * * argp ) 
 { 
 /* Skip '%'.  */ 
 line ++ ; 
 
 /* Skip DECL.  */ 
 for ( const char * d = decl ; * d ; d ++ ) 
 { 
 if ( ! ( line < line_end ) ) 
 return false ; 
 if ( ! ( * line == * d || ( * d == '-' && * line == '_' ) ) ) 
 return false ; 
 line ++ ; 
 } 
 if ( line < line_end 
 && ( ( * line >= 'A' && * line <= 'Z' ) 
 || ( * line >= 'a' && * line <= 'z' ) 
 || * line == '-' || * line == '_' ) ) 
 return false ; 
 
 /* OK, found DECL.  */ 
 
 /* Skip '='.  */ 
 if ( ! ( line < line_end && * line == '=' ) ) 
 { 
 fprintf ( stderr , "%s:%u: missing argument in %%%s=ARG declaration.\n" , 
 pretty_input_file_name ( ) , lineno , decl ) ; 
 exit ( 1 ) ; 
 } 
 line ++ ; 
 
 /* The next word is the argument.  */ 
 char * arg = new char [ line_end - line + 1 ] ; 
 char * p = arg ; 
 while ( line < line_end && ! ( * line == ' ' || * line == '\t' || * line == '\n' ) ) 
 * p ++ = * line ++ ; 
 * p = '\0' ; 
 
 /* Skip whitespace.  */ 
 while ( line < line_end && ( * line == ' ' || * line == '\t' ) ) 
 line ++ ; 
 
 /* Expect end of line.  */ 
 if ( line < line_end && * line != '\n' ) 
 { 
 fprintf ( stderr , "%s:%u: junk after declaration\n" , 
 pretty_input_file_name ( ) , lineno ) ; 
 exit ( 1 ) ; 
 } 
 
 * argp = arg ; 
 return true ; 
 } 
 
 /* Tests if the given line contains a "%define DECL ARG" declaration.
   If yes, it sets *ARGP to the argument, and returns true.
   Otherwise, it returns false.  */ 
 static bool 
 is_define_declaration ( const char * line , const char * line_end , 
 unsigned int lineno , 
 const char * decl , char * * argp ) 
 { 
 /* Skip '%'.  */ 
 line ++ ; 
 
 /* Skip "define".  */ 
 { 
 for ( const char * d = "define" ; * d ; d ++ ) 
 { 
 if ( ! ( line < line_end ) ) 
 return false ; 
 if ( ! ( * line == * d ) ) 
 return false ; 
 line ++ ; 
 } 
 if ( ! ( line < line_end && ( * line == ' ' || * line == '\t' ) ) ) 
 return false ; 
 } 
 
 /* Skip whitespace.  */ 
 while ( line < line_end && ( * line == ' ' || * line == '\t' ) ) 
 line ++ ; 
 
 /* Skip DECL.  */ 
 for ( const char * d = decl ; * d ; d ++ ) 
 { 
 if ( ! ( line < line_end ) ) 
 return false ; 
 if ( ! ( * line == * d || ( * d == '-' && * line == '_' ) ) ) 
 return false ; 
 line ++ ; 
 } 
 if ( line < line_end 
 && ( ( * line >= 'A' && * line <= 'Z' ) 
 || ( * line >= 'a' && * line <= 'z' ) 
 || * line == '-' || * line == '_' ) ) 
 return false ; 
 
 /* OK, found DECL.  */ 
 
 /* Skip whitespace.  */ 
 if ( ! ( line < line_end && ( * line == ' ' || * line == '\t' ) ) ) 
 { 
 fprintf ( stderr , "%s:%u:" 
 " missing argument in %%define %s ARG declaration.\n" , 
 pretty_input_file_name ( ) , lineno , decl ) ; 
 exit ( 1 ) ; 
 } 
 do 
 line ++ ; 
 while ( line < line_end && ( * line == ' ' || * line == '\t' ) ) ; 
 
 /* The next word is the argument.  */ 
 char * arg = new char [ line_end - line + 1 ] ; 
 char * p = arg ; 
 while ( line < line_end && ! ( * line == ' ' || * line == '\t' || * line == '\n' ) ) 
 * p ++ = * line ++ ; 
 * p = '\0' ; 
 
 /* Skip whitespace.  */ 
 while ( line < line_end && ( * line == ' ' || * line == '\t' ) ) 
 line ++ ; 
 
 /* Expect end of line.  */ 
 if ( line < line_end && * line != '\n' ) 
 { 
 fprintf ( stderr , "%s:%u: junk after declaration\n" , 
 pretty_input_file_name ( ) , lineno ) ; 
 exit ( 1 ) ; 
 } 
 
 * argp = arg ; 
 return true ; 
 } 
 
 /* Reads the entire input file.  */ 
 void 
 Input :: read_input ( ) 
 { 
 /* The input file has the following structure:
        DECLARATIONS
        %%
        KEYWORDS
        %%
        ADDITIONAL_CODE
     Since the DECLARATIONS and the ADDITIONAL_CODE sections are optional,
     we have to read the entire file in the case there is only one %%
     separator line, in order to determine whether the structure is
        DECLARATIONS
        %%
        KEYWORDS
     or
        KEYWORDS
        %%
        ADDITIONAL_CODE
     When the option -t is given or when the first section contains
     declaration lines starting with %, we go for the first interpretation,
     otherwise for the second interpretation.  */ 
 
 char * input = NULL ; 
 size_t input_size = 0 ; 
 int input_length = get_delim ( & input , & input_size , EOF , _stream ) ; 
 if ( input_length < 0 ) 
 { 
 if ( ferror ( _stream ) ) 
 fprintf ( stderr , "%s: error while reading input file\n" , 
 pretty_input_file_name ( ) ) ; 
 else 
 fprintf ( stderr , "%s: The input file is empty!\n" , 
 pretty_input_file_name ( ) ) ; 
 exit ( 1 ) ; 
 } 
 
 /* We use input_end as a limit, in order to cope with NUL bytes in the
     input.  But note that one trailing NUL byte has been added after
     input_end, for convenience.  */ 
 char * input_end = input + input_length ; 
 
 const char * declarations ; 
 const char * declarations_end ; 
 const char * keywords ; 
 const char * keywords_end ; 
 unsigned int keywords_lineno ; 
 
 /* Break up the input into the three sections.  */ 
 { 
 const char * separator [ 2 ] = { NULL , NULL } ; 
 unsigned int separator_lineno [ 2 ] = { 0 , 0 } ; 
 int separators = 0 ; 
 { 
 unsigned int lineno = 1 ; 
 for ( const char * p = input ; p < input_end ; ) 
 { 
 if ( p [ 0 ] == '%' && p [ 1 ] == '%' ) 
 { 
 separator [ separators ] = p ; 
 separator_lineno [ separators ] = lineno ; 
 if ( ++ separators == 2 ) 
 break ; 
 } 
 lineno ++ ; 
 p = ( const char * ) memchr ( p , '\n' , input_end - p ) ; 
 if ( p != NULL ) 
 p ++ ; 
 else 
 p = input_end ; 
 } 
 } 
 
 bool has_declarations ; 
 if ( separators == 1 ) 
 { 
 if ( option [ TYPE ] ) 
 has_declarations = true ; 
 else 
 { 
 has_declarations = false ; 
 for ( const char * p = input ; p < separator [ 0 ] ; ) 
 { 
 if ( p [ 0 ] == '%' ) 
 { 
 has_declarations = true ; 
 break ; 
 } 
 p = ( const char * ) memchr ( p , '\n' , separator [ 0 ] - p ) ; 
 if ( p != NULL ) 
 p ++ ; 
 else 
 p = separator [ 0 ] ; 
 } 
 } 
 } 
 else 
 has_declarations = ( separators >
 **/
 0 ) ; 
 
 if ( has_declarations ) == true { 
 { 
 declarations = input ; } 
 declarations_end = separator [ 0 ] ; 
 /* Give a warning if the separator line is nonempty.  */
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static nonempty_line : bool = false; ; 
 const 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & char ; 
 p = declarations_end + 2 ; while p < input_end { 
 { 
 if ( * p == '\n' ) == true { 
 { 
 p +=1 ; } } 
 if ( nonempty_line ) == true { 
 fprintf ( stderr , "%s:%u: warning: junk after %%%% is ignored\n" , 
 pretty_input_file_name ( ) ; separator_lineno [ 0 ] ) ; } 
 keywords = p ; 
 keywords_lineno = separator_lineno [ 0 ] + 1 ; 
 
 else { 
 { 
 declarations = NULL ; } 
 declarations_end = NULL ; 
 keywords = input ; 
 keywords_lineno = 1 ; 
 
 
 if ( separators > ( has_declarations ? 1 : 0 ) == true { ) 
 { 
 keywords_end = separator [ separators - 1 ] ; } 
 _verbatim_code = separator [ separators - 1 ] + 2 ; 
 _verbatim_code_end = input_end ; 
 _verbatim_code_lineno = separator_lineno [ separators - 1 ] ; 
 
 else { 
 { 
 keywords_end = input_end ; } 
 _verbatim_code = NULL ; 
 _verbatim_code_end = NULL ; 
 _verbatim_code_lineno = 0 ; 
 
 
 
 /* Parse the declarations section.  */
 
 
 _verbatim_declarations = NULL ; 
 _verbatim_declarations_end = NULL ; 
 _verbatim_declarations_lineno = 0 ; 
 _struct_decl = NULL ; 
 _struct_decl_lineno = 0 ; 
 _return_type = NULL ; 
 _struct_tag = NULL ; 
 { 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static lineno : i32 = 1; ; 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static struct_decl : & char ; 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static struct_decl_linenos : & i32 ; 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static struct_decl_linecount : i32 = 0; ; 
 const char * ; while line < declarations_end { 
 { 
 const 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static line_end : & char ; } 
 if ( _verbatim_declarations != NULL && _verbatim_declarations_end == NULL ) == true { 
 { 
 fprintf ( stderr , "%s:%u: unterminated %%{ section\n" , 
 pretty_input_file_name ( ) ; _verbatim_declarations_lineno ) ; } 
 exit ( 1 ) ; 
 
 
 /* Determine _struct_decl, _return_type, _struct_tag.  */
 
 if ( option [ TYPE ] ) == true { 
 { 
 if ( struct_decl ) == true { 
 { 
 /* Drop leading whitespace and comments.  */
 
 { 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & char = & ; ; } } 
 unsigned 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static l : & i32 = & ; ; 
 loop { 
 { 
 if ( p [ 0 ] == ' ' || p [ 0 ] == '\t' ) == true { 
 { 
 p +=1 ; } } 
 if ( p != struct_decl ) == true { 
 { 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let len = size_t { }; } 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static new_struct_decl : & char = & char[len+1]; ; 
 memcpy ( new_struct_decl , p , len + 1 ) ; 
 delete [ ] struct_decl ; 
 struct_decl = new_struct_decl ; 
 
 _struct_decl_lineno = * ; 
 
 /* Drop trailing whitespace.  */
 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & char = & +strlen(struct_decl); ; while p > struct_decl { 
 if ( p [ - 1 ] == '\n' || p [ - 1 ] == ' ' || p [ - 1 ] == '\t' ) == true { 
 * p -=1 = '\0' ; } } 
 { 
 /* Ensure trailing semicolon.  */
 
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let old_len = size_t { }; 
 if ( struct_decl [ old_len - 1 ] != ';' ) == true { 
 { 
 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static new_struct_decl : & char = & char[old_len+2]; ; } 
 memcpy ( new_struct_decl , struct_decl , old_len ) ; 
 new_struct_decl [ old_len ] = ';' ; 
 new_struct_decl [ old_len + 1 ] = '\0' ; 
 delete [ ] struct_decl ; 
 struct_decl = new_struct_decl ; 
 
 
 /* Set _struct_decl to the entire declaration.  */
 
 _struct_decl = struct_decl ; 
 /* Set _struct_tag to the naked "struct something".  */
 
 const 
/*Crust with Strict Mode enabled, declares all variables as immutable.
 * If you are mutating the below variable anywhere in program, please change the declaration statement as
 * let mut var_name:type=init_val;
 **/
 static p : & char ; 
 p = struct_decl ; while * p && * p != '{' && * p != ';' && * p != '\n' { 
 ; p +=1 ; } 
 
 /* To be freed in the destructor.  */
 
 _input = input ; 
 _input_end = input_end ; 
 
 
 Input :: Input  ; ( ) 
 { 
 /* Free allocated memory.  */
 
 delete [ ] const_cast < char * > ( _return_type ) ; 
 delete [ ] const_cast < char * > ( _struct_tag ) ; 
 delete [ ] const_cast < char * > ( _struct_decl ) ; 
 delete [ ] _input ; 
 
